'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _require = require('path');

const relative = _require.relative;

const babylon = require('babylon');
const template = require('babel-template');
const t = require('babel-types');
const traverse = require('babel-traverse').default;
const generate = require('babel-generator').default;
const treeShake = require('../scope-hoisting/shake');
const mangleScope = require('../scope-hoisting/mangler');

const EXPORTS_RE = /^\$([\d]+)\$exports$/;
const EXPORT_RE = /^\$([\d]+)\$export\$(.+)$/;

const DEFAULT_INTEROP_TEMPLATE = template('$parcel$interopDefault(MODULE)');
const THROW_TEMPLATE = template('$parcel$missingModule(MODULE)');

module.exports = packager => {
  let code = packager.contents,
      exports = packager.exports,
      addedAssets = packager.addedAssets;
  // console.log(code)

  let ast = babylon.parse(code, {
    allowReturnOutsideFunction: true
  });
  // Share $parcel$interopDefault variables between modules
  let interops = new Map();
  let assets = Array.from(addedAssets).reduce((acc, asset) => {
    acc[asset.id] = asset;

    return acc;
  }, {});

  let resolveModule = (id, name) => {
    let module = assets[id];
    return module.depAssets.get(module.dependencies.get(name));
  };

  function replaceExportNode(id, name, path) {
    let node = find(id, id => `$${id}$export$${name}`);

    if (!node) {
      // if there is no named export then lookup for a CommonJS export
      node = find(id, id => `$${id}$exports`) || t.identifier(`$${id}$exports`);

      // if there is a CommonJS export return $id$exports.name
      return t.memberExpression(node, t.identifier(name));
    }

    return node;

    function find(id, symbol) {
      let computedSymbol = symbol(id);

      // if the symbol is in the scope there is not need to remap it
      if (path.scope.getProgramParent().hasBinding(computedSymbol)) {
        return t.identifier(computedSymbol);
      }

      if (exports.has(computedSymbol)) {
        return t.identifier(exports.get(computedSymbol));
      }

      // default exports are excluded from wildcard exports
      if (id in assets && name !== 'default') {
        /* recursively lookup the symbol
         * this is needed when there is deep export wildcards, like in the following:
         * - a.js
         *   > export * from './b'
         * - b.js
         *   > export * from './c'
         * - c.js in es6
         *   > export * from 'lodash'
         * - c.js in cjs
         *   > module.exports = require('lodash')
         */
        let node = null;

        assets[id].cacheData.wildcards.find(name => node = find(resolveModule(id, name).id, symbol));

        return node;
      }

      return null;
    }
  }

  console.time('concat');

  traverse(ast, {
    CallExpression(path) {
      var _path$node = path.node;
      let args = _path$node.arguments,
          callee = _path$node.callee;


      if (!t.isIdentifier(callee)) {
        return;
      }

      // each require('module') call gets replaced with $parcel$require(id, 'module')
      if (callee.name === '$parcel$require') {
        var _args = _slicedToArray(args, 2);

        let id = _args[0],
            source = _args[1];


        if (args.length !== 2 || !t.isNumericLiteral(id) || !t.isStringLiteral(source)) {
          throw new Error('invariant: invalid signature, expected : $parcel$require(number, string)');
        }

        let mod = resolveModule(id.value, source.value);

        if (!mod) {
          if (assets[id.value].dependencies.get(source.value).optional) {
            path.replaceWith(THROW_TEMPLATE({ MODULE: t.stringLiteral(source.value) }));
          } else {
            throw new Error(`Cannot find module "${source.value}" in asset ${id.value}`);
          }
        } else {
          path.replaceWith(t.identifier(`$${mod.id}$exports`));
        }
      } else if (callee.name === '$parcel$import') {
        var _args2 = _slicedToArray(args, 4);

        let id = _args2[0],
            source = _args2[1],
            name = _args2[2],
            replace = _args2[3];


        replace = path.get('arguments.3').evaluate();

        if (args.length !== 4 || !t.isNumericLiteral(id) || !t.isStringLiteral(source) || !t.isStringLiteral(name) // ||
        // !t.isBooleanLiteral(replace)
        ) {
            throw new Error('invariant: invalid signature, expected : $parcel$import(number, string, string, boolean)');
          }

        let mod = resolveModule(id.value, source.value);

        if (typeof mod === 'undefined') {
          throw new Error(`Cannot find module "${source.value}" in asset ${id.value}`);
        }

        let node = replaceExportNode(mod.id, name.value, path);
        let interop = false;

        // If the module has any CommonJS reference, it still can have export/import statements.
        if (mod.cacheData.isCommonJS) {
          if (name.value === 'default') {
            node = t.isMemberExpression(node) ? node.object : node;
            interop = true;

            let nodeName = replace.value && t.isIdentifier(node) ? node.name : null;
            let id = path.parent.id;


            if (nodeName !== null && interops.has(nodeName)) {
              let name = t.identifier(interops.get(nodeName));

              // Rename references to the variables to the cached interop name.
              path.scope.getBinding(id.name).referencePaths.forEach(reference => reference.replaceWith(t.memberExpression(name, t.identifier('d'))));
              // Remove the binding and its definition.
              path.scope.removeBinding(id.name);
              path.parentPath.remove();

              return;
            } else {
              node = DEFAULT_INTEROP_TEMPLATE({ MODULE: node });

              // Save the variable name of the interop call for further use.
              if (nodeName !== null) {
                interops.set(nodeName, id.name);
              }
            }
          }
        } else if (mod.cacheData.isES6Module && !t.isIdentifier(node) && mod.id in assets) {
          let relativePath = relative(packager.options.rootDir, mod.name);

          throw new Error(`${relativePath} does not export '${name.value}'`);
        }

        if (replace.value) {
          if (!path.parentPath.isVariableDeclarator()) {
            throw new Error('invariant: "replace" used outside of a VariableDeclarator');
          }

          let id = path.parent.id;

          let binding = path.scope.getBinding(id.name);

          if (interop) {
            path.replaceWith(node);

            binding.referencePaths.forEach(reference => reference.replaceWith(t.memberExpression(id, t.identifier('d'))));
          } else {
            path.scope.removeBinding(id.name);

            binding.path.remove();
            binding.referencePaths.forEach(reference => reference.replaceWith(node));

            if (t.isIdentifier(node)) {
              exports.set(id.name, node.name);
            }
          }
        } else {
          path.replaceWith(node);
        }
      } else if ((callee.name === '$parcel$interopDefault' || callee.name === '$parcel$exportWildcard') && !path.getData('markAsPure')) {
        // This hints Uglify and Babel that this CallExpression does not have any side-effects.
        path.addComment('leading', '#__PURE__');
        path.setData('markAsPure', true);
      } else if (callee.name === '$parcel$require$resolve') {
        var _args3 = _slicedToArray(args, 2);

        let id = _args3[0],
            source = _args3[1];


        if (args.length !== 2 || !t.isNumericLiteral(id) || !t.isStringLiteral(source)) {
          throw new Error('invariant: invalid signature, expected : $parcel$require$resolve(number, string)');
        }

        let mapped = assets[id.value];
        let dep = mapped.dependencies.get(source.value);
        let mod = mapped.depAssets.get(dep);
        let bundles = mod.id;

        if (dep.dynamic && packager.bundle.childBundles.has(mod.parentBundle)) {
          bundles = [packager.getBundleSpecifier(mod.parentBundle)];

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = mod.parentBundle.siblingBundles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              let child = _step.value;

              if (!child.isEmpty) {
                bundles.push(packager.getBundleSpecifier(child));
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          bundles.push(mod.id);
        }

        path.replaceWith(t.valueToNode(bundles));
      }
    },
    VariableDeclarator: {
      exit(path) {
        // Replace references to declarations like `var x = require('x')`
        // with the final export identifier instead.
        // This allows us to potentially replace accesses to e.g. `x.foo` with
        // a variable like `$id$export$foo` later, avoiding the exports object altogether.
        var _path$node2 = path.node;
        let id = _path$node2.id,
            init = _path$node2.init;

        if (!t.isIdentifier(init)) {
          return;
        }

        if (EXPORTS_RE.test(init.name)) {
          let binding = path.scope.getBinding(id.name);
          if (!binding.constant) {
            return;
          }

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = binding.referencePaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              let ref = _step2.value;

              ref.replaceWith(t.identifier(init.name));
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          path.remove();
        }
      }
    },
    MemberExpression: {
      exit(path) {
        if (!path.isReferenced()) {
          return;
        }

        var _path$node3 = path.node;
        let object = _path$node3.object,
            property = _path$node3.property;

        if (!t.isIdentifier(object) || !t.isIdentifier(property)) {
          return;
        }

        let match = object.name.match(EXPORTS_RE);

        // If it's a $id$exports.name expression.
        if (match) {
          let exportName = '$' + match[1] + '$export$' + property.name;

          // Check if $id$export$name exists and if so, replace the node by it.
          if (path.scope.hasBinding(exportName)) {
            path.replaceWith(t.identifier(exportName));
          }
        }
      }
    },
    ReferencedIdentifier(path) {
      let name = path.node.name;


      if (typeof name !== 'string') {
        return;
      }

      // If it's a renamed export replace it with its alias.
      if (exports.has(name)) {
        path.replaceWith(t.identifier(exports.get(path.node.name)));
      }

      let match = name.match(EXPORT_RE);

      // If it's an undefined $id$export$name identifier.
      if (match && !path.scope.hasBinding(name)) {
        let id = Number(match[1]);
        let exportName = match[2];

        // Check if there is a wildcard or an alias (Identifier), else use CommonJS (MemberExpression).
        path.replaceWith(replaceExportNode(id, exportName, path));

        return;
      }

      match = name.match(EXPORTS_RE);

      // If it's an undefined $id$exports identifier.
      if (match && !path.scope.hasBinding(name)) {
        let id = Number(match[1]);

        // If the id is in the bundle it may just be empty, replace with {}.
        if (id in assets) {
          path.replaceWith(t.objectExpression([]));
        }
        // Else it should be required from another bundle, replace with require(id).
        else {
            path.replaceWith(t.callExpression(t.identifier('require'), [t.numericLiteral(id)]));
          }

        return;
      }
    },
    Program: {
      // A small optimization to remove unused CommonJS exports as sometimes Uglify doesn't remove them.
      exit(path) {
        treeShake(path.scope);

        if (packager.options.minify) {
          mangleScope(path.scope);
        }
      }
    }
  });

  console.timeEnd('concat');

  let opts = {
    sourceMaps: packager.options.sourceMaps,
    sourceFileName: packager.bundle.name,
    minified: packager.options.minify,
    comments: !packager.options.minify
  };

  console.time('generate');
  let res = generate(ast, opts, code);
  console.timeEnd('generate');
  console.log('\n\n');
  return res;
};